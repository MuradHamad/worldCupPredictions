---
phase: 03-scoring-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: []
autonomous: true
requirements: [SCR-01, SCR-02, SCR-03, SCR-04, SCR-05, SCR-06, SCR-07]

must_haves:
  truths:
    - "Match results can be stored in database"
    - "Scoring algorithm calculates points correctly"
    - "Leaderboard displays ranked users by score"
    - "Room members see all participants' scores"
    - "Tiebreaker rules applied when scores are equal"
  artifacts:
    - path: "world-cup-predictor/prisma/schema.prisma"
      provides: "MatchResult model for storing actual results"
      exports: "MatchResult type with matchId, winnerTeamId, round"
    - path: "world-cup-predictor/src/app/api/scoring/route.ts"
      provides: "POST scoring calculation endpoint"
      exports: "calculateScores function"
    - path: "world-cup-predictor/src/app/api/leaderboard/route.ts"
      provides: "GET leaderboard data endpoint"
      exports: "getLeaderboard function"
    - path: "world-cup-predictor/src/app/leaderboard/page.tsx"
      provides: "Leaderboard page with ranked users"
      exports: "LeaderboardPage component"
  key_links:
    - from: "src/app/api/scoring/route.ts"
      to: "/api/predictions"
      via: "GET request"
      pattern: "fetch.*predictions.*user"
    - from: "src/app/leaderboard/page.tsx"
      to: "/api/leaderboard"
      via: "GET request"
      pattern: "fetch.*leaderboard"
---

<objective>
Implement the Scoring System to calculate points based on prediction accuracy and display leaderboards. This includes storing match results, calculating user scores, and showing ranked leaderboards.

Purpose: Users compete with friends by earning points for correct predictions
Output: /leaderboard page with scoring functionality
</objective>

<execution_context>
@C:/Users/lenovo/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/lenovo/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@world-cup-predictor/prisma/schema.prisma
@world-cup-predictor/src/app/api/predictions/route.ts
@world-cup-predictor/src/app/summary/page.tsx
@world-cup-predictor/src/app/rooms/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add MatchResult model to database schema</name>
  <files>world-cup-predictor/prisma/schema.prisma</files>
  <action>
Add MatchResult model to store actual match outcomes:

1. Add MatchResult model with fields:
   - id: String (cuid)
   - matchId: String (unique) - identifies the match (e.g., "r32-1", "group-A-1")
   - round: String - "GROUP", "ROUND_OF_32", "ROUND_OF_16", "QUARTER_FINAL", "SEMI_FINAL", "THIRD_PLACE", "FINAL"
   - groupName: String? - for group stage matches (A-L)
   - winnerTeamId: String? - the team that won
   - team1Score: Int? - optional score for ties
   - team2Score: Int? - optional score for ties
   - isComplete: Boolean - whether result is confirmed
   - createdAt: DateTime
   - updatedAt: DateTime

2. Run `npx prisma generate` to update client
3. Run `npx prisma db push` to update database

This model stores the "ground truth" - the actual results that predictions are compared against.
  </action>
  <verify>1. Check prisma schema includes MatchResult model
2. Run prisma generate and db push
3. Verify database has new table (check with prisma studio or sqlite3)</verify>
  <done>MatchResult model exists in schema and database, can store match outcomes</done>
</task>

<task type="auto">
  <name>Task 2: Create API endpoint for managing match results</name>
  <files>world-cup-predictor/src/app/api/matches/route.ts</files>
  <action>
Create API endpoint to manage match results:

1. Create GET endpoint to fetch all match results
2. Create POST endpoint to create/update match results (admin only now - room for creator can set results)
3. Store results using MatchResult model

The POST should accept:
- matchId: string
- round: string (GROUP, ROUND_OF_32, etc.)
- winnerTeamId: string (team that won)
- groupName: optional for group matches
- team1Score, team2Score: optional for tie scenarios
  </action>
  <verify>1. POST a test match result
2. GET match results to verify storage
3. Verify data persists correctly</verify>
  <done>API endpoint can store and retrieve match results</done>
</task>

<task type="auto">
  <name>Task 3: Create scoring calculation API</name>
  <files>world-cup-predictor/src/app/api/scoring/route.ts</files>
  <action>
Create the scoring calculation endpoint:

1. Define scoring rules:
   - Group winner: 10 points per group
   - Group ranking (exact position): 5 points per team position
   - Knockout winner: 5 points (R32), 10 (R16), 15 (QF), 25 (SF), 50 (Final)
   - Third place: 20 points
   - Exact position bonus: If user's predicted position matches exactly, 5 bonus points per team

2. Create POST /api/scoring that:
   - Takes roomId as input (optional - defaults to user's room)
   - Fetches all predictions for users in the room
   - Fetches all match results
   - Calculates points for each user based on:
     * Compare prediction.teamOrder[0] (winner) with matchResult.winnerTeamId
     * For group rankings, compare full teamOrder array
   - Updates RoomMember.score for each user
   - Returns calculated scores

3. Handle tiebreakers:
   - Primary: Highest score wins
   - Secondary: First to submit predictions (createdAt from earliest prediction)
   - Store tiebreaker as submittedAt timestamp on first prediction
  </action>
  <verify>1. Add some match results via /api/matches
2. Call /api/scoring with test predictions
3. Verify scores are calculated correctly
4. Check RoomMember records updated</verify>
  <done>Scoring API correctly calculates points based on predictions vs results</done>
</task>

<task type="auto">
  <name>Task 4: Create leaderboard API endpoint</name>
  <files>world-cup-predictor/src/app/api/leaderboard/route.ts</files>
  <action>
Create the leaderboard API:

1. Create GET /api/leaderboard that accepts:
   - roomId: string (optional, returns global if not provided)
   
2. Returns:
   - Array of users with scores, sorted by:
     * Total score (descending)
     * Tiebreaker: earliest first prediction (ascending)
   - Each entry includes:
     * userId, userName, userImage
     * score (total points)
     * rank (position 1, 2, 3...)
     * predictionsCount (how many predictions made)
     * tiebreaker timestamp

3. For room-specific leaderboard:
   - Fetch all RoomMembers for the room
   - Include user details from User relation
   - Sort by score desc, then by first prediction createdAt asc
  </action>
  <verify>1. Call /api/leaderboard without roomId - returns global rankings
2. Call /api/leaderboard?roomId=xxx - returns room-specific rankings
3. Verify sorting is correct (highest score first)</verify>
  <done>Leaderboard API returns correctly sorted user rankings</done>
</task>

<task type="auto">
  <name>Task 5: Create Leaderboard page UI</name>
  <files>world-cup-predictor/src/app/leaderboard/page.tsx</files>
  <action>
Create the leaderboard page:

1. Create /leaderboard page with:
   - Header with navigation back to dashboard
   - Room selector dropdown (if user is in multiple rooms)
   - Leaderboard table/list showing:
     * Rank (1st, 2nd, 3rd with medal icons)
     * User avatar and name
     * Score points
     * Number of correct predictions
   - "Recalculate Scores" button (calls scoring API)
   - Empty state if no scores yet

2. Design:
   - Use glassmorphism cards (existing design pattern)
   - Gold/Silver/Bronze highlighting for top 3
   - Current user highlighted
   - Smooth animations with Framer Motion

3. Fetch data on mount:
   - Get user's rooms
   - Get leaderboard for selected room (default to first room)
  </action>
  <verify>1. Navigate to /leaderboard
2. See leaderboard with users and scores
3. Select different room - leaderboard updates
4. Click recalculate - scores update
5. Mobile responsive layout works</verify>
  <done>Leaderboard page displays ranked users with scores in polished UI</done>
</task>

<task type="auto">
  <name>Task 6: Add leaderboard link to dashboard</name>
  <files>world-cup-predictor/src/app/dashboard/page.tsx</files>
  <action>
Update the dashboard to include leaderboard access:

1. Read existing dashboard/page.tsx
2. Add "Leaderboard" card/link that navigates to /leaderboard
3. Show user's current rank and score in the card (if in a room)
4. Follow existing card design patterns
  </action>
  <verify>1. Check dashboard has leaderboard navigation
2. Clicking navigates to /leaderboard
3. Card shows user's current standing</verify>
  <done>Dashboard includes leaderboard access point</done>
</task>

<task type="checkpoint:human-verify">
  <name>Checkpoint: Verify Scoring System</name>
  <action>
Manually verify the complete scoring flow:

1. **Add Match Results**: Use /api/matches to add some test results
   - Add group winner predictions
   - Add knockout winner predictions

2. **Make Predictions**: Ensure predictions exist that match the results
   - Some should be correct
   - Some should be incorrect

3. **Calculate Scores**: Call /api/scoring to calculate points

4. **View Leaderboard**: Visit /leaderboard to see ranked results

5. **Verify Points**:
   - Correct group winner = 10 points
   - Correct knockout winner (R32) = 5 points
   - Correct knockout winner (R16) = 10 points
   - Correct knockout winner (QF) = 15 points
   - Correct knockout winner (SF) = 25 points
   - Correct final winner = 50 points
   - Third place = 20 points

Report the scores observed and confirm they match expected values.
  </action>
</task>

</tasks>

<verification>
- MatchResult model exists in database schema
- /api/matches endpoint can store/retrieve results
- /api/scoring calculates points correctly
- /api/leaderboard returns sorted rankings
- /leaderboard page displays polished leaderboard
- Dashboard has leaderboard link
- Tiebreaker (first to submit) works correctly
</verification>

<success_criteria>
1. Match results can be stored in database (SCR-01, SCR-02, SCR-03, SCR-04)
2. Scoring algorithm implemented with correct point values (SCR-01 to SCR-04)
3. Tiebreaker rules applied (SCR-05)
4. Leaderboard displays ranked users (SCR-06)
5. Room members see all participants' scores (SCR-07)
</success_criteria>

<output>
After completion, create `.planning/phases/03-scoring-system/03-SUMMARY.md`
</output>
